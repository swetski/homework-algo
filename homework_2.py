#!/usr/bin/env python
# coding: utf-8

# **Практическое задание 2**
# 
# **Домашнее задание: бинарный поиск**

# **Условие задачи**
# 
# Написать функцию бинарного поиска по отсортированному массиву целых чисел.
# 
# **Требования**
# 
# Функция должна:
# - принимать на вход отсортированный массив int[] array и число int target,
# - возвращать индекс элемента target в массиве, если он там есть,
# - возвращать -1, если элемента нет.
# 
# *Важно:*
# 
# - Реализация должна быть без рекурсии, через цикл while.
# - Используем две границы поиска: левую и правую.
# 

# **Что нужно сдать**
# 1. Код функции binarySearch.
# 2. Тесты (примеры вызова) — в main, в отдельном методе, или просто в комментарии:
# - случай, когда искомый элемент находится в начале массива;
# - случай, когда искомый элемент находится в конце массива;
# - случай, когда элемента в массиве нет.
# 
# *Пример массива, который можно использовать:int[] data = {1, 3, 5, 7, 9, 11, 13}*
# 
# 3. Короткое письменное пояснение (в комментарии кода или отдельным блоком текста): 
# - Почему бинарный поиск нельзя применять к неотсортированному массиву?
# - Какая асимптотическая сложность алгоритма по времени и почему это O(log n)?
# - Какая сложность по памяти?

# In[7]:


def binary_search(array, target):
    # Функция ищет target в отсортированном array и возвращает индекс или -1

    left = 0
    # left — левый край области поиска (самый первый индекс)

    right = len(array) - 1
    # right — правый край области поиска (самый последний индекс)

    while left <= right:
        # Пока область поиска не “сломалась” (есть что искать)

        mid = left + (right - left) // 2
        # mid — середина текущего отрезка [left, right]
        # // 2 — целочисленное деление (получаем целый индекс)

        if array[mid] == target:
            # Если элемент в середине равен тому, что ищу — нашла
            return mid

        elif array[mid] < target:
            # Если середина меньше target — target может быть только правее
            left = mid + 1
            # Сдвигаю левую границу вправо, исключая mid (я уже проверила mid)

        else:
            # Иначе (array[mid] > target): target может быть только левее
            right = mid - 1
            # Сдвигаю правую границу влево, исключая mid

    return -1
    # Если вышла из цикла — область поиска стала пустой, элемента нет


# In[8]:


data = [1, 3, 5, 7, 9, 11, 13]

print(binary_search(data, 1))   # ожидаю 0 (в начале)
print(binary_search(data, 13))  # ожидаю 6 (в конце)
print(binary_search(data, 4))   # ожидаю -1 (нет)


# **Короткое письменное пояснение:**

# 1. Почему бинарный поиск нельзя применять к неотсортированному массиву?
# 
# Бинарный поиск основан на сравнении искомого элемента со значением посередине массива и дальнейшем выборе одной из половин массива для продолжения поиска.
# Но такая логика работает только в случае, если массив отсортирован.
# В неотсортированном массиве невозможно определить, в какой части может находиться искомый элемент, поэтому алгоритм может отбросить часть массива, содержащую нужное значение и вернуть неверный результат.

# 2. Какая асимптотическая сложность алгоритма по времени и почему это O(log n)?
# 
# Асимптотическая сложность бинарного поиска по времени равна O(log n), где n — количество элементов в массиве.
# Это обусловлено тем, что на каждом шаге алгоритм сокращает область поиска вдвое (отбрасывая половину элементов).
# Количество шагов, необходимых для нахождения элемента или завершения поиска, растёт логарифмически от размера массива.

# 3. Какая сложность по памяти?
# 
# Бинарный поиск имеет постоянную сложность по памяти — O(1), так как использует фиксированное количество дополнительных переменных left, right, mid и не создаёт новых структур данных, объём их зависит от размера входного массива.
